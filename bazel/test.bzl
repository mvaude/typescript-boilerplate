"Shows how you might create a macro for the autogenerated Jest rule"

load("@build_bazel_rules_nodejs//:providers.bzl", "DeclarationInfo", "JSModuleInfo")
load("@npm//jest-cli:index.bzl", "jest", _jest_test = "jest_test")

def _jest_deps_impl(ctx):
   declarations = []
   files = []

   for dep in ctx.attr.deps:
       if dep[DeclarationInfo]:
           declarations.append(dep[DeclarationInfo].declarations)
       if dep[JSModuleInfo]:
           files.append(dep[JSModuleInfo].sources)

   return [
       DefaultInfo(files = depset(transitive = files + declarations)),
       DeclarationInfo(transitive_declarations = depset(transitive = declarations)),
   ]

_jest_deps = rule(
   implementation = _jest_deps_impl,
   attrs = {
       "deps": attr.label_list(),
   }
)

def jest_test(name, srcs, deps, jest_config, timeout, **kwargs):
    "A macro around the autogenerated jest_test rule"
    templated_args = [
        "--no-cache",
        "--no-watchman",
        "--ci",
        "--colors",
    ]
    templated_args.extend(["--config", "$(rootpath %s)" % jest_config])
    for src in srcs:
        templated_args.extend(["--runTestsByPath", "$(rootpath %s)" % src])

    jest_deps = "%s.deps" % name
    _jest_deps(
      name = jest_deps,
      deps = deps,
    )
    data = [jest_config] + [jest_deps] + srcs
    _jest_test(
        name = name,
        data = data,
        templated_args = templated_args,
        timeout = timeout,
        **kwargs
    )

    # This rule is used specifically to update snapshots via `bazel run`
    jest(
        name = "%s.update" % name,
        data = data,
        templated_args = templated_args + ["-u"],
        **kwargs,
    )